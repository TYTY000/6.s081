#中断和陷阱机制
中断是指外部设备或硬件向CPU发出信号，要求CPU暂停当前的执行流，去处理紧急事件。中断通常是无感的，即进程不会察觉到中断的发生。有硬件和软件中断。

异常是指在程序执行过程中发生的意外事件，例如除零错误、非法内存访问等。异常通常会导致系统panic，终止当前进程。
    异常向量表：存储异常处理程序的入口地址。
    异常处理优先级：不同类型的异常有不同的优先级，处理时按照优先级顺序进行。

系统调用是用户态进程主动请求内核服务的机制。系统调用比中断更复杂，因为它涉及到用户态和内核态之间的上下文切换。

#中断处置
通常分成三类中断：
    用户态中断：在用户程序运行时触发，处理时需要切换到内核态。
    内核态中断：在内核程序运行时触发，处理时不需要切换状态。
    定时中断：由定时器触发，用于实现时间片轮转等功能。

处理陷阱的内核代码通常称为处理程序（handler），负责保存现场、处理中断、恢复现场，并返回中断前的执行状态。
第一个处理程序指令通常是用汇编语言(而不是C语言)编写的，有时被称为vector。

主要涉及4个部分：
1.RISCV CPU进行的硬件操作
2.内核C代码封装的汇编代码
3.一个实现特定功能的C函数
4.系统调用和常规的设备驱动

#RISCV陷阱机制
相关特权指令：只能在内核态执行，用于管理系统资源和控制硬件设备。
   stvec: 保存陷阱向量基地址。
   sepc: 中断返回地址。
   scause: 中断原因。
   sscratch: a0的临时保存寄存器。
   sstatus: SIE位保存中断使能，SPP位保存中断前模式。

进入设备中断的状态机模型：
1.用sstatus检查SIE，如果允许中断：
2.用sstatus清空SIE
3.用sepc将pc拷贝至sepc
4.用sstatus将当前状态拷贝至sstatus的SPP位
5.用scause设置中断原因
6.设置特权模式
7.将stvec拷贝至pc
8.在新pc处开始执行
注：中断相当于轻量级的系统调用，不强制保存上下文，由软件选择。

#用户态中断
使用uservec/ret来保存/恢复寄存器的值；使用usertrap(ret)找到对应trap的类型并进入/返回。
1.uservec：用户态中断向量表，存储用户态中断处理程序的入口地址。
    用sscratch寄存器和a0寄存器交换，用a0来临时保存内存中32个寄存器数据保存的地址，并且将a0指向的中断帧映射到satp指向的根页表中、a1指向用户页表地址，sscratch来临时保存a0；
    读取中断帧中的内核栈地址、CPU ID、中断函数的地址和核页表的地址，并调用中断。
2.usertrap：用户态中断处理程序，负责处理用户态中断。
    将pc保存到sepc寄存器，因为可能由于进程调度，中断也会交出控制权，要写入stvec中确保sepc能够恢复；
    如果是系统调用，就syscall（需要在保存的stvec += 4，回来以后继续执行）；如果是设备中断，调用处理函数；剩下的就是异常，直接杀掉。
    检查状态，看有没有被杀、是不是时间中断。
3.usertrapret：用户态中断返回函数，负责恢复用户态的执行状态。
	将stvec指向uservec、恢复sepc、恢复中断帧；
	调用userret负责恢复寄存器的值。
4.userret：用户态返回函数，负责从内核态返回到用户态。
	蹦床页保存在a0中，用户页表在a1中。
	先将satp指向用户页表，恢复a0，获取中断帧，通过sret恢复至用户空间。

> [!NOTE] 代码实现tips 
> 在RISCV规范中，明确a7寄存器保存系统调用的序号，a0和a1放exec的参数；返回时，返回值保存在a0中。
> 系统调用的序号会对应系统调用函数（封装的函数指针数组），然后ecall指令会进入用户态中断，将现场保存在中断帧（进程独有？）中；
> 然后syscall进入内核态，根据a7寄存器进入相应的系统调用。

#内核态中断
1.kernelvec：内核态中断向量表，存储内核态中断处理程序的入口地址。
	因为此时已经在内核态，可以直接使用satp来访问内核根页表，将当前现场保存至当前进程的内核栈上；
2.kerneltrap：内核态中断处理程序，负责处理内核态中断。
	内核态就没有系统调用了，此时只有中断和异常需要处理（devintr / panic）。
	kerneltrap执行完后返回kernelvec，如果kernelvec也执行完，会从内核栈的中断帧的数据中执行sret。
> [!NOTE] 定时中断
> 定时中断由定时器触发，处理时需要更新系统时间和调度任务。
> 如果kerneltrap是由于定时器中断而被调用，并且进程的内核线程正在运行（而不是调度程序线程），kerneltrap会调用yield以给其他线程运行的机会。
> 然后其他某个线程会yield，返回时，由于已经提前保存了内核态现场，所以能够保证状态的恢复。
> 因为yield 会随机执行其他一个内核态中断，内核线程不多，所以整体运行是畅通的。
> 定时中断的陷阱返回的过程如下：
 >   1.kerneltrap保存sepc和sstatus中的先前模式。
 >   2.kerneltrap调用yield，切换到其他线程。
  >  3.当我们的线程再次运行时，kerneltrap恢复sepc和sstatus。
  >  4.kerneltrap返回到kernelvec。
  >  5.kernelvec从栈中弹出保存的寄存器并执行sret，将sepc复制到pc并恢复中断的内核代码。


> [!NOTE] 小漏洞？
> RISC-V在开始处理陷阱时总是禁用中断，xv6在设置stvec之后才重新启用它们。

#缺页异常
缺页异常处理程序负责查找缺页原因、分配新页、更新页表，并恢复执行。

> [!NOTE] Tips
> xv6对待异常的方式非常简单粗暴。但是实际系统不是这样。

#页表错误处理
页表错误处理程序负责查找错误原因、修复页表项，并恢复执行。
#### 常见原因：
1.页表中没有这个地址
2.对应地址的PTE_V非法
3.权限错误

RISCV对页表错误的区分：
1.读页异常
2.写页异常
3.指令地址异常
（将其原因保存在scause寄存器中，地址保存在stval寄存器中）

场景：
本质上是对空间和时间复杂度进行分摊。
downside：分配本质上涉及内核态调用，有时间空间开销。
处理方法：批处理页错误。
1.COW  写时复制，经典的内存优化策略
父子进程对应页面的PTE_W都为0，修改会产生权限错误异常：重新拷贝、重新映射并调整权限（懒），回到原进程。
	需要一个类似shared_ptr的引用计数。
	优化例子：fork & exec

2.懒式分配：只有在实际需要时才分配内存，以节省资源。
新创建的页（虚拟映射）头一次被使用（PTE_V为0，访问会产生缺页异常）
	优化例子：应用通常会索取比实际需求更多的资源。

3.需求分页（懒式加载）：只有在访问页面时才加载页面，以提高内存利用率。
对应页的PTE_V为0，在出现页错误时再进行实际加载

4.磁盘分页（IO缓存机制）：将不常用的页面存储到磁盘上，以腾出内存空间。
相当于内存和磁盘间的缓存机制。换出、写入到磁盘就是非法，换进、读取进内存就是合法。

#不懒反而更麻烦
原因：无论提供了多少RAM，系统剩余的物理内存都不会太多。（明显不用证明）
因此，当空闲物理内存稀缺时，分配前需要先驱逐。所以懒分配和需求分页在内存稀缺时特别有利。
如果不懒地分配，除了额外驱逐成本外，会反复浪费时间做无用功（在使用之前，可能又将其驱逐）。
其他利用上述特性的功能包括自动扩展堆栈和内存映射文件等。

#xv6和工业级的差别
RISC-V在强制陷阱时尽量减少操作，以实现快速陷阱处理。
Xv6利用【RISC-V提供的受保护寄存器】特性实现了蹦床页和中断帧，为了减少安全漏洞和复杂性而避免使用其他优化方法。

> [!NOTE] 工业级关于中断陷阱的优化方法：
>    中断优先级掩码：为CPU设置中断优先级掩码，通过屏蔽低优先级中断，提高高优先级中断的处理效率。
>    中断抢占策略：在多个中断事件同时到来时，选择优先级最高的中断进行处理。
>    中断现场保护优化：根据中断服务子程序对通用寄存器的需求，减少中断现场保护时所需保护的通用寄存器数量，缩短中断响应时间，提高系统的中断实时性。

工业级的操作系统通过将内核内存映射到每个进程的用户页表中，可以消除蹦床页的需求，并避免从用户空间陷入内核时的页表切换；
还实现了写时复制fork、懒式分配、需求分页、磁盘分页和内存映射文件等功能，并尽量利用所有物理内存。Xv6在这方面较为简单，内存不足时会返回错误或终止应用程序。
