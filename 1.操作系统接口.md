#基本框架
用户态、内核态之间通过中断或陷阱指令等系统调用进行转换，系统调用是主动暴露的安全接口。
通过fork、exec来进行进程功能的延续/转换。fork 创建一个新进程，exec 用新程序替换当前进程的内存空间。
PID、系统调用序号本质就是偏移量，一个程序进程信息/系统调用函数的偏移量。

如果是cd这样的简单操作，无需fork。
如果是cat这种切换进程状态的操作，就用exec去切换。

> [!NOTE] exec
> execl、execlp、execle
> execv、execvp、execve
> 其中l表示定长、v表示边长；p表示系统环境变量PATH中搜索可执行文件，e表示自定义环境变量。

需要设立解析token和执行的函数，针对普通、执行、重定向、管道、列表、后台命令等进行针对性处理。

#IO 
FD是每个进程独有的，用于独立的跟踪进程打开的文件（关联的FD），由内核进行维护和创建。
具体的，文件的读写由系统调用根据权限类型执行，对硬盘或缓存中的数据进行映射和读取。内核会维护缓存、状态、下标等信息，直到文件被关闭。

#pipe
管道通过复制文件描述符实现进程间通信。管道实际上是一个内存缓冲区，具有两个文件描述符：一个用于读取，另一个用于写入。
1.无需创建和清理临时文件 2. 不受文件系统大小限制 3.可阻塞 4.允许并行

#dup 
复制一个文件描述符，使得两个文件描述符指向同一个文件表项。自动从低fd开始获取。

#close
关闭一个文件描述符，使其不再引用任何文件，并且可以被重用。


举例
```c
  case PIPE:
    pcmd = (struct pipecmd*)cmd;
    if(pipe(p) < 0)
      panic("pipe");
    if(fork1() == 0){
      close(1);
      dup(p[1]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->left);
    }
    if(fork1() == 0){
      close(0);
      dup(p[0]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->right);
    }
    close(p[0]);
    close(p[1]);
    wait(0);
    wait(0);
    break;
```
实际上是在父进程中关闭了读写端，然后分别在两个子进程中通过stdin、stdout进行拼接实现pipe的功能。