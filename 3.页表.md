#页表机制 
页表机制负责判断内存地址是什么，并且哪些物理内存可以被访问，从而使得进程间的隔离、物理内存的复用得以实现。
实际上是一个三级导航的机制，让OS得以控制在4KB 粒度的分页上的虚拟和物理地址转换。

> [!NOTE] 页表的结构
> #Sv39的RISCV
> 1.即高25位预留，低39位（即512GB）去掉物理地址的12位低位地址后，PTE表有27位，所以逻辑上支持$2^{27}$ 个的页表项（PTE）；
> 2.每个页表项是44位物理页编号（PPN）和分页的状态位（共54位）。
> 3.分页硬件负责将虚拟地址的39位中的高27位去访问页表中的PTE，进而获得实际物理地址（PPN的高44位地址和PTE低12位状态位的组合，共54位，还有10位的预留空间）。
![[Pasted image 20240913135749.png]]
> 单级页表示意图。
![[Pasted image 20240913140838.png]]
> 三级页表示意图，更加节约内存，因为内存偏碎片化离散随机分布在虚拟地址空间中。

#TLB 
三级页表虽然大幅减少页表元数据的数据量，但是会使得CPU频繁进行IO，所以引入了TLB（转译后备缓冲区）。本质上是一个LRU的硬件缓存器。

#SATP寄存器
保存了根页表的地址（各核私有），因为进程绑定到了CPU，CPU切换的时候地址也需要切换。


> [!NOTE] 页表本质上也是一种映射
> 页目录（Page Directory）和页表都存储在物理内存中，内核可以通过写入虚拟地址来修改页表条目的内容，从而改变虚拟地址到物理地址的映射。
> 这正是抽象机制的一个重要体现。通过这种抽象，内核可以简化对复杂硬件操作的管理。
> 	1.内核提出修改指令：内核负责生成和管理页表，但它不需要直接与硬件交互。它只需要提出修改页表的指令。
> 	2.IO部分代码实施：负责IO的部分代码会接收到这些指令，并实际执行对页表的修改。这些代码通常会处理具体的硬件操作，如写入内存地址等。
> 	此处都是虚拟地址，具体的硬件去负责物理地址查找。


#内核地址空间
![[Pasted image 20240913144812.png]]
内核地址除了蹦床页和内核栈均使用直接映射。
> [!NOTE] 为什么要直接映射
> 直接映射在访问内存时可以直接通过简单的加法运算得到物理地址，而不需要复杂的页表查找。
> 减少地址转换的开销：直接映射减少了地址转换过程中页表查找的次数，从而降低了访问内存的延迟。
> 简化内核代码：由于地址转换变得简单，内核代码的实现也相对简化，减少了出错的可能性。
> 提高访问效率：直接映射使得内核在处理频繁的内存访问时更加高效，特别是在处理器高速缓存命中率较高的情况下。

内核栈的地址很高，在其后加一个非法的Guard page （虚拟的，物理内存上不存在）用于检测栈溢出（直接panic）。

> [!NOTE] 为什么内核虚拟地址除了蹦床页和内核栈外都是直接映射？
> 蹦床页是所有进程共享的、用于保存、恢复CPU状态的一个buffer，所有进程共享，用汇编代码确保访问/调用时能保存/恢复CPU状态。
> 内核栈则是每个进程独有的，通常分配在内核地址空间的高端。

#初始栈的结构
![[Pasted image 20240913155333.png]]
通过判断0 来遍历有多少个参数，然后根据对称的关系去获取第i个参数的地址和内容。