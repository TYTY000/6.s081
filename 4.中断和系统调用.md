#中断和陷阱机制
中断是指外部设备或硬件向CPU发出信号，要求CPU暂停当前的执行流，去处理紧急事件。中断通常是无感的，即进程不会察觉到中断的发生。
异常是指在程序执行过程中发生的意外事件，例如除零错误、非法内存访问等。异常通常会导致系统panic，终止当前进程。
系统调用是用户态进程主动请求内核服务的机制。系统调用比中断更复杂，因为它涉及到用户态和内核态之间的上下文切换。

#中断处置
通常分成三类中断：
用户态、内核态、定时中断。
处理陷阱的内核代码通常称为处理程序（handler）。
第一个处理程序指令通常是用汇编语言(而不是C语言)编写的，有时被称为vector。

主要涉及4个部分：
1.RISCV CPU进行的硬件操作
2.内核C代码封装的汇编代码
3.一个实现特定功能的C函数
4.系统调用和常规的设备驱动

#RISCV陷阱机制
相关特权指令：
   stvec: 内核在此寄存器中写入其陷阱处理程序的地址；RISC-V在处理陷阱时跳转到stvec中的地址。
   sepc: 当发生陷阱时，RISC-V将程序计数器保存到此寄存器中（因为pc会被stvec中的值覆盖）。sret（从陷阱返回）指令将sepc复制到程序计数器。内核可以写入sepc以控制sret返回的位置。
   scause: RISC-V在此寄存器中放置一个描述陷阱原因的数字。
   sscratch: 内核在此寄存器中放置一个值，在陷阱处理程序的开始阶段非常有用。
   sstatus: sstatus中的SIE位控制设备中断是否启用。如果内核清除SIE，RISC-V将推迟设备中断，直到内核设置SIE。SPP位指示陷阱是来自用户模式还是监督模式，并控制sret返回到哪个模式。

进入设备中断的状态机模型：
1.用sstatus检查SIE，如果允许中断：
2.用sstatus清空SIE
3.用sepc将pc拷贝至sepc
4.用sstatus将当前状态拷贝至sstatus的SPP位
5.用scause设置中断原因
6.设置特权模式
7.将stvec拷贝至pc
8.在新pc处开始执行
注：中断相当于轻量级的系统调用，不强制保存上下文，由软件选择。

#用户态中断
使用uservec/ret来保存/恢复寄存器的值；使用usertrap(ret)找到对应trap的类型并进入/返回。
1.uservec主要是保存现场：
    用sscratch寄存器和a0寄存器交换，用a0来临时保存内存中32个寄存器数据保存的地址，并且将a0指向的中断帧映射到satp指向的根页表中、a1指向用户页表地址，sscratch来临时保存a0；
    读取中断帧中的内核栈地址、CPU ID、中断函数的地址和核页表的地址，并调用中断。
2.usertrap会判断中断类型、处理并返回。
    将pc保存到sepc寄存器，因为可能由于进程调度，中断也会交出控制权，要写入stvec中确保sepc能够恢复；
    如果是系统调用，就syscall（需要在保存的stvec += 4，回来以后继续执行）；如果是设备中断，调用处理函数；剩下的就是异常，直接杀掉。
    检查状态，看有没有被杀、是不是时间中断。
3.usertrapret
	将stvec指向uservec、恢复sepc、恢复中断帧；
	调用userret负责恢复寄存器的值。
4.userret
	蹦床页保存在a0中，用户页表在a1中。
	先将satp指向用户页表，恢复a0，获取中断帧，通过sret恢复至用户空间。